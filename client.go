package issh

import (
	//"flag"
	"fmt"
	"code.google.com/p/go.crypto/ssh"
	"code.google.com/p/go.text/unicode/norm"
	"crypto"
	"crypto/dsa"
	"errors"
	"io"
	//"log"
	"math/big"
	"os"
)

var params = new(dsa.Parameters)

func init() {
	// DSA is, in fact, magic.
	//
	// The following parameters were generated by running the following:
	//
	// rand, err := os.Open("/dev/random")
	// if err != nil {
	// 		log.Fatal(err)
	// }
	// params := &dsa.Parameters{}
	// dsa.GenerateParameters(params, rand, dsa.L1024N160)

	p := new(big.Int)
	q := new(big.Int)
	g := new(big.Int)
	p.SetString("130642166864071203463239656097142341904849140585061951688300554757362446260459711015276785142716962093655971678415305010178504645568749836389662343575542044953158554083710831561767706187442995193738502273669649751195940235762018514847090237231566556373715643322892832134201611037437507602732266200147426795869", 10)
	q.SetString("866027036905107857165250601876454956505869932401", 10)
	g.SetString("15284915559640922295701167939060760431573292860750463294432125788754593787689836410450118841587502197221502866876130530682745129044909044676364738263255648853955413358807735405761167385002477797988499139113209107838415780033584924889374456168509962142218427774887842421443178977675377807721820371439485027135", 10)
	params.P = p
	params.Q = q
	params.G = g
}

type keyring struct {
	key *dsa.PrivateKey
}

var KeyringError = errors.New("Invalid key specified")

func (k *keyring) Key(i int) (ssh.PublicKey, error) {
	if i != 0 {
		return nil, nil
	}

	ssh_key, err := ssh.NewPublicKey(&k.key.PublicKey)
	if err != nil {
		return nil, err
	}
	return ssh_key, nil
}

func (k *keyring) Sign(i int, rand io.Reader, data []byte) ([]byte, error) {
	hasher := crypto.SHA1.New()
	hasher.Write(data)
	digest := hasher.Sum(nil)

	r, s, err := dsa.Sign(rand, k.key, digest)
	if err != nil {
		return nil, err
	}

	sig := make([]byte, 40)

	rBytes := r.Bytes()
	copy(sig[20-len(rBytes):], rBytes)

	sBytes := s.Bytes()
	copy(sig[40-len(sBytes):], sBytes)

	return sig, nil
}

func generateKey(seed_token string) (key *dsa.PrivateKey) {
	g, p, q := params.G, params.P, params.Q
	token_runes := norm.NFC.String(seed_token)
	x := big.NewInt(0)
	for _, run := range token_runes {
		x.Lsh(x, 32)
		x.Add(x, big.NewInt(int64(run)))
	}
	x.Mod(x, q)
	y := big.NewInt(0)
	y.Exp(g, x, p)
	key = &dsa.PrivateKey{
		PublicKey: dsa.PublicKey{
			Parameters: dsa.Parameters{
				G: g,
				P: p,
				Q: q,
			},
			Y: y,
		},
		X: x,
	}
	return
}

func GetAuthorizedKey(seed string) ([]byte, error) {
	key := generateKey(seed)
        ssh_key, err := ssh.NewPublicKey(&key.PublicKey)
	if err != nil {
		return nil, err
	}
	return ssh.MarshalAuthorizedKey(ssh_key), nil
}

func Run(username, hostname string, port uint16, seed string) ([]byte, int, error) {
	key := generateKey(seed)

	config := &ssh.ClientConfig{
		User: username,
		Auth: []ssh.ClientAuth{
			ssh.ClientAuthKeyring(&keyring{key: key}),
		},
	}

	client, err := ssh.Dial("tcp", fmt.Sprintf("%s:%d", hostname, port), config)
	if err != nil {
		return nil, 0, err
	}
	defer client.Close()

	session, err := client.NewSession()
	if err != nil {
		return nil, 0, err
	}
	defer session.Close()

	bytes, err := session.Output("exit 1")
	if err != nil {
		if exiterror, ok := err.(*ssh.ExitError); ok {
			return bytes, exiterror.ExitStatus(), nil
			os.Stdout.Write(bytes)
			os.Exit(exiterror.ExitStatus())
		} else {
			return nil, 0, err
		}
	}
	return bytes, 0, nil
}
